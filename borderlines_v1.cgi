#!/usr/bin/perl## max number of borderlines to story#$max = 5;## where do we send the user when they are done playing?#$return_URL = "http://atthefaire.com/index.htm";## if you want to count how many play the game, specify# a path to the count data file here, else leave it empty.#$datafile_path = "borderlines.dat";## location/name of this script ... hopefully you won't have to change# this, but if you do it should be something like "/cgi-bin/guessgame.cgi"# or wherver your script is and whatever it is called...#$this_script = "$ENV{'SCRIPT_NAME'}";###################################################################################### begin processing... nothing below this line needs to be modified#&ReadParse;# see if we have a special mode to work with...$mode = $in{'mode'};# if no input, then just show a borderlineif (!$in){	open( FILE,$datafile_path) || die ("Unable to open file.\n" );	print "Content-Type: text/html\n\n";	# read borderlines into an array	@borderlines = <FILE>;	# get number of borderlines	$entries = scalar(@borderlines);		# print a random borderline	$random = int(rand($entries))+1;	my $subset = @borderlines[$random];		print "<div>$subset</div>\n";		close(FILE);	exit(0);}if ($mode eq "add"){	&do_top;		print "<p align=\"center\">Welcome to Sub-Etha Software's BORDERLINES!</p>\n";	open( FILE,$datafile_path) || die ("Unable to open file.\n" );	# read borderlines into an array	@borderlines = <FILE>;	$entries = scalar(@borderlines);		print "<p>There are $entries borderlines right now:</p>\n";		$count=0;	foreach $line ( @borderlines ) {		$count++;		print "<div>$count. $line</div>\n";	}	close(FILE);		&do_form;		$ip = $ENV{REMOTE_ADDR};	print "<p align=\"center\"><b>NOTE:</b> Your IP address of $ip will be logged.</a>\n";	&do_end;	exit(0);}## if we have a message, place it in the borderline file## get the user's borderline message$message = $in{'message'};# get rid of invalid stuff from the messageif ($message) {	# get rid of trailing carraige return	chomp $message;		# filter out HTML tags	$message =~ s/<[^>]*>//g;}# okay, NOW see if we have something to put in the file...if ($message) {	# read old group	open(FILE, "+<$datafile_path");	@borderlines = <FILE>;		# add new message to the top	unshift (@borderlines, $message);		seek (FILE,0,0);	truncate(FILE,0);	# get rid of any excess messages (over our storage limit).	while ( @borderlines>$max ) {		pop @borderlines;	}	foreach $line ( @borderlines )	{		chomp( $line );		print FILE "$line\n";	#	print "<div>$line</div>\n";	}	close(FILE);}	## if here, we don't know why were were called, so just redirect...## send browser to return page.print "Location: $return_URL\n\n";	exit(0);sub do_top{	print "Content-Type: text/html\n\n";	print "<html><head><title>Sub-Etha's BORDERLINES...</title><head><body>\n";}sub do_end{	print "</body></html>\n";}sub do_form{print <<EOF;<form action="$this_script" method="post"><p align="center">Enter your own borderline:</p><div align="center">Message:<input type="text" name="message" size="80" maxlength="80"><input type="submit" name="mode" value="Submit"><input type="submit" name="mode" value="Cancel"></div></form>EOF}sub play_again{print <<EOF;<form action="$this_script" method="post"><div align="center">Would you like to play again?<input type="submit" name="playagain" value="Yes"><input type="submit" name="playagain" value="No"></div></form>EOF}########################################################################################## Adapted from cgi-lib.pl by S.E.Brenner@bioc.cam.ac.uk### Copyright 1994 Steven E. Brennersub ReadParse {local (*in) = @_ if @_;local ($i, $key, $val);### replaced his MethGet functionif ( $ENV{'REQUEST_METHOD'} eq "GET" ) {	$in = $ENV{'QUERY_STRING'};} elsif ($ENV{'REQUEST_METHOD'} eq "POST") {	read(STDIN,$in,$ENV{'CONTENT_LENGTH'});} else {	# Added for command line debugging	# Supply name/value form data as a command line argument	# Format: name1=value1\&name2=value2\&...	# (need to escape & for shell)	# Find the first argument that's not a switch (-)	$in = ( grep( !/^-/, @ARGV )) [0];	$in =~ s/\\&/&/g;}@in = split(/&/,$in);foreach $i (0 .. $#in) {	# Convert plus's to spaces	$in[$i] =~ s/\+/ /g;	# Split into key and value.	($key, $val) = split(/=/,$in[$i],2); # splits on the first =.	# Convert %XX from hex numbers to alphanumeric	$key =~ s/%(..)/pack("c",hex($1))/ge;	$val =~ s/%(..)/pack("c",hex($1))/ge;	# Associate key and value. \0 is the multiple separator	$in{$key} .= "\0" if (defined($in{$key}));	$in{$key} .= $val;	}	return length($in);}